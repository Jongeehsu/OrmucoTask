package Assignment3;

import redis.clients.jedis.Jedis;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class GeoRedisLruCache<K, V> {

    private final Map<K, CacheEntry<V>> cache;
    private final long cacheExpirationTimeMillis;
    private final ScheduledExecutorService evictionScheduler;
    private final Jedis jedis;
    private final int cacheSize;
    private final String region;



    public GeoRedisLruCache(int maxSize, long cacheExpirationTimeMillis, int cacheSize, String redisHost, int redisPort, String region) {

        // Set expiration time and cache size. To specify the location where data is uploaded, region info could also be submitted. The data structure LinkedHashmap is implemented to meet LRU design logic.
        this.cacheExpirationTimeMillis = cacheExpirationTimeMillis;
        this.cacheSize = cacheSize;
        this.region = region;
        this.cache = new LinkedHashMap<K, CacheEntry<V>>(maxSize, 0.8f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, CacheEntry<V>> eldest) {
                return size() > maxSize;
            }
        };
        //The evictionScheduler was used to trigger evictExpiredEntries method kicking out the data that is expired.
        this.evictionScheduler = Executors.newScheduledThreadPool(1);
        this.evictionScheduler.scheduleAtFixedRate(this::evictExpiredEntries, 0, 1, TimeUnit.MINUTES);

        //Jedis Set up info
        this.jedis = new Jedis(redisHost, redisPort);
    }


    //Put logicï¼Œput the data into Redis
    public void put(K key, V value) {
        CacheEntry<V> entry = new CacheEntry<>(value, System.currentTimeMillis());
        cache.put(key, entry);


        String redisKey = generateRedisKey(key);
        jedis.set(redisKey, value.toString());
        jedis.expire(redisKey, (int) TimeUnit.MILLISECONDS.toSeconds(cacheExpirationTimeMillis));
    }


    //retrieve data
    public V get(K key) {
        CacheEntry<V> entry = cache.get(key);
        if (entry != null) {
            entry.setLastAccessed(System.currentTimeMillis());
            return entry.getValue();
        }

        // retrieve the data from Redis
        String redisKey = generateRedisKey(key);
        String redisValue = jedis.get(redisKey);
        if (redisValue != null) {
            V value = (V) redisValue;
            // Refresh the local cache
            put(key, value);
            return value;
        }

        return null;
    }

    //The expiration logic, every 1 minute the stored data would be checked whether it's expired or not.
    private void evictExpiredEntries() {
        long currentTime = System.currentTimeMillis();
        cache.entrySet().removeIf(entry -> (currentTime - entry.getValue().getLastAccessed()) >= cacheExpirationTimeMillis);
    }



    //Use region prefix together with key to generate Key for HashMap storage.
    private String generateRedisKey(K key) {
        return region + ":" + key.toString();
    }



    //The Java bean CacheEntry  was created. The core attributes of it is targeted value and last Accssed info generated by System function currentTimeMillis.
    private static class CacheEntry<V> {
        private final V value;
        private long lastAccessed;

        CacheEntry(V value, long lastAccessed) {
            this.value = value;
            this.lastAccessed = lastAccessed;
        }

        V getValue() {
            return value;
        }

        long getLastAccessed() {
            return lastAccessed;
        }

        void setLastAccessed(long lastAccessed) {
            this.lastAccessed = lastAccessed;
        }
    }




    public static void main(String[] args) {
        GeoRedisLruCache<String, String> cache = new GeoRedisLruCache<>(10, TimeUnit.MINUTES.toMillis(10), 100, "localhost", 6379, "us-east");

        cache.put("key1", "value1");
        cache.put("key2", "value2");

        System.out.println(cache.get("key1"));
        System.out.println(cache.get("key3"));
    }
}
